import{_ as i,c as r,b as e,e as d,d as t,a,r as c,o as n}from"./app.1f6db2cb.js";const ke=JSON.parse('{"title":"你真的了解消息队列吗","description":"","frontmatter":{"title":"你真的了解消息队列吗","date":"2022-11-11T00:00:00.000Z","excerpt":"一篇文章带你探寻消息队列的几个基础功能的原理","tags":["mq","消息队列","kafka","time wheel"]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"术语","slug":"术语","link":"#术语","children":[{"level":3,"title":"基础","slug":"基础","link":"#基础","children":[]},{"level":3,"title":"消息类型","slug":"消息类型","link":"#消息类型","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]},{"level":2,"title":"消费模式","slug":"消费模式","link":"#消费模式","children":[{"level":3,"title":"推模式（push）","slug":"推模式-push","link":"#推模式-push","children":[]},{"level":3,"title":"拉模式（pull）","slug":"拉模式-pull","link":"#拉模式-pull","children":[]}]},{"level":2,"title":"常见消息队列功能","slug":"常见消息队列功能","link":"#常见消息队列功能","children":[]},{"level":2,"title":"投递&消费语义","slug":"投递-消费语义","link":"#投递-消费语义","children":[{"level":3,"title":"投递语义","slug":"投递语义","link":"#投递语义","children":[]},{"level":3,"title":"消费语义","slug":"消费语义","link":"#消费语义","children":[]}]},{"level":2,"title":"功能特性","slug":"功能特性","link":"#功能特性","children":[{"level":3,"title":"事务消息","slug":"事务消息","link":"#事务消息","children":[]},{"level":3,"title":"延迟消息","slug":"延迟消息","link":"#延迟消息","children":[]},{"level":3,"title":"顺序消息","slug":"顺序消息","link":"#顺序消息","children":[]},{"level":3,"title":"消息轨迹","slug":"消息轨迹","link":"#消息轨迹","children":[]}]},{"level":2,"title":"稳定性&性能","slug":"稳定性-性能","link":"#稳定性-性能","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"relativePath":"post/message-queue.md","lastUpdated":1673449434000}'),l={name:"post/message-queue.md"},s=e("h1",{id:"你真的了解消息队列吗",tabindex:"-1"},[t("你真的了解消息队列吗 "),e("a",{class:"header-anchor",href:"#你真的了解消息队列吗","aria-hidden":"true"},"#")],-1),h=a("",12),p=a("",26),u=a("",11),g=e("code",null,"Kafka",-1),m=e("code",null,"1ms",-1),_=e("code",null,"TimerTaskList",-1),b=e("code",null,"TimerTask",-1),f=e("code",null,"0",-1),k=e("code",null,"2ms",-1),y=e("code",null,"8ms",-1),T=e("code",null,"2ms",-1),x=e("code",null,"8ms",-1),I=e("code",null,"10ms",-1),C=e("code",null,"10ms",-1),S=e("code",null,"2ms",-1),q=e("code",null,"19ms",-1),A=e("code",null,"2ms",-1),P=e("code",null,"19ms",-1),B=e("code",null,"21ms",-1),z=e("code",null,"21ms",-1),D=e("code",null,"2ms",-1),v=e("code",null,"22ms",-1),L=e("code",null,"2ms",-1),j=e("code",null,"22ms",-1),O=e("code",null,"24ms",-1),M=e("code",null,"24ms",-1),w=e("code",null,"24ms",-1),N=e("code",null,"24ms",-1),E=e("code",null,"40",-1),V=e("code",null,"[0-399s]",-1),Q=e("code",null,"60",-1),R=e("code",null,"[0-7999s]",-1),H=a("",6),Y=a("",2),W=e("code",null,"TimerLog",-1),K=e("code",null,"TimerWheel",-1),J=e("h5",{id:"工作流程",tabindex:"-1"},[t("工作流程 "),e("a",{class:"header-anchor",href:"#工作流程","aria-hidden":"true"},"#")],-1),G=a("",12),Z={class:"details custom-block"},U=e("summary",null,"答案2",-1),F=e("code",null,"key",-1),X=e("h3",{id:"消息轨迹",tabindex:"-1"},[t("消息轨迹 "),e("a",{class:"header-anchor",href:"#消息轨迹","aria-hidden":"true"},"#")],-1),$=e("p",null,"一条消息的生命周期包含多个阶段：发送端发送，服务端收到消息、写入消息、投递消息等。而用户在使用MQ时，有时会想知道消息的发送、投递、消费情况，以及消费耗时、消费节点、是否重投等信息。这些信息都属于消息轨迹。 在没有可视化的消息轨迹界面时，轨迹信息都是通过原始的翻日志的方式来查询。需要根据机器节点的日志信息找到链路，一步一步溯源查找。",-1),ee=a("",7),te=e("h5",{id:"消费一致性",tabindex:"-1"},[t("消费一致性 "),e("a",{class:"header-anchor",href:"#消费一致性","aria-hidden":"true"},"#")],-1),oe=e("h4",{id:"高性能",tabindex:"-1"},[t("高性能 "),e("a",{class:"header-anchor",href:"#高性能","aria-hidden":"true"},"#")],-1),de=e("h5",{id:"零拷贝",tabindex:"-1"},[t("零拷贝 "),e("a",{class:"header-anchor",href:"#零拷贝","aria-hidden":"true"},"#")],-1),ae=e("h5",{id:"磁盘顺序读写",tabindex:"-1"},[t("磁盘顺序读写 "),e("a",{class:"header-anchor",href:"#磁盘顺序读写","aria-hidden":"true"},"#")],-1),ie=e("h4",{id:"msgbroker",tabindex:"-1"},[t("msgbroker "),e("a",{class:"header-anchor",href:"#msgbroker","aria-hidden":"true"},"#")],-1),re=e("h4",{id:"rocketmq",tabindex:"-1"},[t("rocketmq "),e("a",{class:"header-anchor",href:"#rocketmq","aria-hidden":"true"},"#")],-1),ce=e("h5",{id:"_1-逻辑分区",tabindex:"-1"},[t("1. 逻辑分区 "),e("a",{class:"header-anchor",href:"#_1-逻辑分区","aria-hidden":"true"},"#")],-1),ne=e("h5",{id:"_2-持久化",tabindex:"-1"},[t("2. 持久化 "),e("a",{class:"header-anchor",href:"#_2-持久化","aria-hidden":"true"},"#")],-1),le=a("",4),se=a("",5);function he(pe,ue,ge,me,_e,be){const o=c("q-img");return n(),r("div",null,[s,e("p",null,[d(o,{src:"/post/message-queue/intro.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),h,e("p",null,[d(o,{src:"/post/message-queue/pull&push.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),p,e("p",null,[d(o,{src:"/post/message-queue/shiwu.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),u,e("ol",null,[e("li",null,[e("p",null,[g,t("中一个时间轮(TimingWheel)默认是由20个时间格组成，每格的时间跨度是"),m,t("，时间轮底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。"),_,t("是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务"),b,d(o,{src:"/post/message-queue/shijianlun1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("假设初始的时候一个格子一秒，时间轮的指针定格在"),f,t("。此时添加一个超时时间为"),k,t("的任务, 那么这个任务将会插入到第二个时间格中 "),d(o,{src:"/post/message-queue/shijianlun2.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("时间轮的指针到达第二个时间格时, 会处理该时间格上对应的任务 "),d(o,{src:"/post/message-queue/shijianlun3.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("如果这个时候又插入一个延时时间为"),y,t("的任务进来, 这个任务的过期时间就是在当前时间"),T,t("的基础上加"),x,t(", 也就是"),I,t(", 那么这个任务将会插入到过期时间为"),C,t("的时间格中。 "),d(o,{src:"/post/message-queue/shijianlun4.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("如果在当前时间是"),S,t("的时候, 插入一个延时时间为"),q,t("的任务时, 这个任务的过期时间就是在当前时间"),A,t("的基础上加"),P,t(", 也就是"),B,t("，那么这个任务就会插入到过期时间为"),z,t("的时间格中 "),d(o,{src:"/post/message-queue/shijianlun5.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("如果在当前时间是"),D,t("的时候, 插入一个延时时间为"),v,t("的任务, 这个任务的过期时间就是在"),L,t("的基础上加"),j,t("，也就是"),O,t("，但是显然没有"),M,t("的格子 "),d(o,{src:"/post/message-queue/shijianlun6.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("第一层的时间轮装不下的时候，任务就会放入第二层的时间轮格子中 "),d(o,{src:"/post/message-queue/shijianlun7.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("当第二层时间轮上的任务到期后，就会执行时间轮的降级，原本超时时间为"),w,t("的任务会被从第二层取出来，放入第一层到期时间为"),N,t("的格子中 "),d(o,{src:"/post/message-queue/shijianlun8.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("从这里可以看出时间轮的巧妙之处，两层时间轮只用了"),E,t("个数组元素，却可以承载"),V,t("的定时任务。而三层时间轮用"),Q,t("个数组元素，就可以承载"),R,t("的定时任务 "),d(o,{src:"/post/message-queue/shijianlun9.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])])]),H,e("ol",null,[Y,e("li",null,[e("p",null,[W,t("与"),K,t("的协作如下图所示： "),d(o,{src:"/post/message-queue/r_shijianlun1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])])]),J,e("p",null,[d(o,{src:"/post/message-queue/r_shijianlun1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),G,e("details",Z,[U,e("p",null,[t("答：消费者端创建多个内存队列，具有相同"),F,t("的数据都路由到同一个内存队列；然后每个线程分别消费一个内存队列即可，这样可以保证多个顺序的同时尽可能提高吞吐量 "),d(o,{src:"/post/message-queue/shunxu.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),X,$,e("p",null,[d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667220447378-24e397ad-a285-40dd-9047-88803459af4a.png#clientId=ud471318f-e47b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1455&id=u7ee5a91b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1455&originWidth=2971&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149879&status=done&style=none&taskId=u3841ca9f-2858-4740-8fd8-585f899378c&title=&width=2971",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" 既然把消息轨迹当成消息存储在Broker服务器，那存储消息轨迹的Topic如何确定呢？RocketMQ提供了两种方法来定义消息轨迹的Topic。")]),ee,e("p",null,[d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/__puml/e43f0a1abf02d76ab7097deea0187b2d.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJzZW5kZXIgLT4gYnJva2VyXG5icm9rZXIgLT4gZGIgOiBzYXZlIG1zZ1xuYnJva2VyIC0tPiBzZW5kZXIgOiBhY2svbmFja1xuYnJva2VyIC0-IHJlY2VpdmVyXG5yZWNlaXZlciAtLT4gYnJva2VyIDogYWNrL25hY2tcbmJyb2tlciAtPiBkYiA6IGRlbGV0ZSBtc2ciLCJ1cmwiOiJodHRwczovL2ludHJhbmV0cHJveHkuYWxpcGF5LmNvbS9za3lsYXJrL2xhcmsvX19wdW1sL2U0M2YwYTFhYmYwMmQ3NmFiNzA5N2RlZWEwMTg3YjJkLnN2ZyIsImlkIjoiYm1QU0IiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t("##### 数据备份和故障转移 "),d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666871933931-97904c34-ab95-4778-9266-8a724d652213.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=ue475ed04&margin=%5Bobject%20Object%5D&name=image.png&originHeight=483&originWidth=1037&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59699&status=done&style=none&taskId=u85dd854e-7f54-4fe9-8d6c-addca350b18&title=&width=518.5",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),te,e("p",null,[d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666873658825-a41e31e0-f7dd-44e7-910c-f1a497841dd2.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=153&id=ubf45f24c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=306&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=155906&status=done&style=none&taskId=ud3f002cb-af85-4049-9add-af69a19790c&title=&width=540",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" LogEndOffset：每个partition的log最后一条Message的位置。 HighWatermark：取最小LEO，consumer能够看到的此partition的位置。")]),oe,de,e("p",null,[d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666874105184-a225b43d-bbc7-4cea-8f4f-cb05291be5c7.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=432&id=ucafb9bc6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=863&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=189782&status=done&style=none&taskId=uac12c40c-6569-448a-8259-d74addcb9f2&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666874115020-9996005b-36a2-4f0a-8051-824c5dd11908.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=427&id=u415102c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=853&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=183715&status=done&style=none&taskId=u05425056-2410-46d7-81fa-5cea881538c&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),ae,e("p",null,[d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666874264460-8cbf0497-6148-4bea-bf87-49a800ef3d51.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=u655e9fe8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113276&status=done&style=none&taskId=u89e9f7da-7792-4ca4-b578-3412e933ab6&title=&width=323",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),ie,e("p",null,[d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1666927224363-d5f358d6-4c94-4714-999a-d247de701a1b.png#clientId=ue9277cdc-a3a4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=357&id=u919d22b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=357&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74259&status=done&style=none&taskId=u7baec6c9-8d01-4648-8a19-0f428f8915e&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" 在2.0的模型中将normal message table拆分为了多个表，并且在逻辑上组成了一个环，按照时间进行写入表的切换，并且定期批量的进行过期表中的数据删除。消息投递之后只会记录 checkpoint，标记哪些消息已经可以删除了，而不会真正执行 normal message table 中的数据删除，从而避免了频繁的插入和删除操作。可以简单的理解为2.0的模型写入就是不断的 Append 消息（checkpoint 可以理解为 offset），投递就是不断的推进checkpoint，删除是批量的对过期的表（不再进行读写）进行删除。")]),e("p",null,[d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1666755832767-cae32c00-2718-4c29-b71e-1ef860b3eb73.png#clientId=u33216851-4002-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=606&id=u16911af2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=757&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=314793&status=done&style=none&taskId=u5872799b-7230-4dd4-b8c1-db8cc3cd08e&title=&width=1200",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" MsgBroker 2.0的计算模型设计中采用了全异步的模型，对各个开销较高的操作都做了异步化，比如msg-write-threads（消息写入线程池）仅负责消息写入时的业务逻辑，并不处理持久化操作。持久化操作是耗时的，由msg-flush-threads批量进行持久化，这样能使 msg-write-threads 更快的去处理更多的写入请求。基于这样的设计，能对各个阶段不同的线程池做精细化的配置，提升资源利用率和整体的性能。")]),re,e("p",null,[d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667303564561-2f07e1f6-7659-42fd-af1c-e6158b2b660d.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=540&id=u0afcf2aa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=540&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=151090&status=done&style=none&taskId=u69fe3af1-8ba5-496f-b9cd-2e6f00ec9b2&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),ce,e("p",null,[t("为了提升整体的吞吐量与提供跨副本组的高可用能力，RocketMQ 服务端一般会为单个 Topic 创建多个逻辑分区，即在多个副本组上各自维护部分分区 ( Partition)，我们把它称为队列 (MessageQueue)。同一个副本组上同一个 Topic 的队列数相同并从 0 开始连续编号，不同副本组上的 MessageQueue 数量可以不同。 "),d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667211128802-1ebe1226-c430-4b6b-a95b-64ae84602146.png#clientId=u732f2838-f0ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=610&id=u13a63bf6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=217091&status=done&style=none&taskId=u1a163547-d3c6-45a3-bacb-68c9b9605a3&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" 每个Topic在Broker上会划分成几个逻辑队列，每个逻辑队列保存一部分消息数据。从上面模型可以看出，要解决消费并发，就是要利用Queue,一个Topic可以分出更多的queue,每一个queue可以存放在不同的硬件上来提高并发。")]),ne,e("p",null,[t("在RocketMQ中消息刷盘主要可以分为同步刷盘和异步刷盘两种。 "),d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667301973880-fbab5567-a642-42b6-8ead-7fa8e666e23d.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=540&id=u5e5e4647&margin=%5Bobject%20Object%5D&name=image.png&originHeight=908&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48292&status=done&style=none&taskId=u1e3a47a0-19e3-4baa-b8f2-559591abd3e&title=&width=347",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" 消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。")]),e("p",null,[d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667302024113-a2ca21dc-b78c-4e84-a005-2a84c19c0f75.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=592&id=ud39bf6fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=906&originWidth=542&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49898&status=done&style=none&taskId=uc5830126-bfa6-4900-9880-40955d7f100&title=&width=354",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" 在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘操作，快速写入。")]),le,e("p",null,[t("批量消息是指将多条小的消息合并成一个批量消息，一次发送出去。这样的好处是可以减少网络IO，提升吞吐量。 比如说原本我有三条消息,如果三条消息分三次发的话,会走三次网络IO,如果我给三条消息整成一起发送,这样就走一次网络了。 "),d(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667304196521-865cb3ee-ab0d-4c62-90e5-7b6cf5bff2f4.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=846&id=uec728440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=846&originWidth=1402&originalType=binary&ratio=1&rotation=0&showTitle=false&size=220474&status=done&style=none&taskId=u2ccac6c3-73d4-409a-9418-120c3c6ec4c&title=&width=1402",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),se])}const ye=i(l,[["render",he]]);export{ke as __pageData,ye as default};
