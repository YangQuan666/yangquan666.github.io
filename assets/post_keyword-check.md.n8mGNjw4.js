import{a7 as s,D as n,C as a,Z as l,ao as p,ap as o,aq as e,ar as c,as as t,at as r,au as y,av as A,aw as i,ax as C,ay as B,az as F}from"./chunks/framework.YixF1Q1-.js";const w=JSON.parse('{"title":"几种常见的关键词匹配算法介绍","description":"","frontmatter":{"title":"几种常见的关键词匹配算法介绍","date":"2022-07-10T00:00:00.000Z","excerpt":"本文介绍几种Java常见的关键词识别算法，包括暴力匹配、字典树和KMP。通过代码示例和详细解释，帮助读者深入理解和应用关键词识别算法在Java编程中的作用","tags":["关键词匹配","算法","Java"]},"headers":[],"relativePath":"post/keyword-check.md","filePath":"post/keyword-check.md","lastUpdated":1684750328000}'),D={name:"post/keyword-check.md"},d=l('<h1 id="几种常见的关键词匹配算法介绍" tabindex="-1">几种常见的关键词匹配算法介绍 <a class="header-anchor" href="#几种常见的关键词匹配算法介绍" aria-label="Permalink to &quot;几种常见的关键词匹配算法介绍&quot;">​</a></h1><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>做内容安全有个很重要的能力就是文本关键词检测，比如检测一段话中是否含有“法轮功”等敏感字段，这就涉及到关键词匹配算法，因此我整理的一些常见的关键词匹配算法，同时加上了自己做的gif图还有自己写的的代码，希望能让读者比较容易理解算法的工作原理</p><h2 id="名词解释" tabindex="-1">名词解释 <a class="header-anchor" href="#名词解释" aria-label="Permalink to &quot;名词解释&quot;">​</a></h2><ul><li>原文<code>content</code>：待检测的文本内容</li><li>关键词<code>keyword</code>：希望匹配的敏感词</li><li>关键词库：由关键词组成的集合</li></ul><h2 id="朴素算法" tabindex="-1">朴素算法 <a class="header-anchor" href="#朴素算法" aria-label="Permalink to &quot;朴素算法&quot;">​</a></h2><p>又称暴力匹配，这个算法很容易理解，就是将原文和关键词进行逐个比较，一致时则继续比较下一字符，直到比较完整个模式串。不一致时则将原文后移一位，重新从模式串的首位开始对比</p><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li><strong>优点</strong>：算法实现简单</li><li><strong>缺点</strong>：性能低</li></ul><h3 id="演示" tabindex="-1">演示 <a class="header-anchor" href="#演示" aria-label="Permalink to &quot;演示&quot;">​</a></h3><p><img src="'+p+`" style="max-height:400px;" loading="lazy"></p><h3 id="代码解读" tabindex="-1">代码解读 <a class="header-anchor" href="#代码解读" aria-label="Permalink to &quot;代码解读&quot;">​</a></h3><p>枚举原文<code>content</code>中的每个字符作为“发起点”，每次从<code>content</code>的“发起点”和<code>keyword</code>的“首位”开始尝试匹配：</p><ul><li>匹配成功：返回本次匹配的原串“发起点”</li><li>匹配失败：从<code>content</code>的下一个“发起点”，重新尝试匹配</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#F47067;">public</span><span style="color:#F47067;"> int</span><span style="color:#DCBDFB;"> find</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] content, </span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword) {</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> n</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> content.length, m </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> keyword.length;</span></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (n </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (m </span><span style="color:#F47067;">==</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">    // k用来记录“发起点”</span></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> k</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">; k </span><span style="color:#F47067;">&lt;=</span><span style="color:#ADBAC7;"> n </span><span style="color:#F47067;">-</span><span style="color:#ADBAC7;"> m; k</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> k, j </span><span style="color:#F47067;">=</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#F47067;">        while</span><span style="color:#ADBAC7;"> (j </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">&amp;&amp;</span><span style="color:#ADBAC7;"> content[i] </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> keyword[j]) {</span></span>
<span class="line"><span style="color:#ADBAC7;">            i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">            j</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#F47067;">        if</span><span style="color:#ADBAC7;"> (j </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> m) {</span></span>
<span class="line"><span style="color:#F47067;">            return</span><span style="color:#ADBAC7;"> k;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><h3 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><p>假设content长度为n，keyword长度为m，则：</p><ul><li>匹配单个keyword时间复杂度：O(n*m)</li><li>匹配k个keyword组成的词库时间复杂度：O(k*m*n)</li></ul><h2 id="朴素算法-改进版" tabindex="-1">朴素算法-改进版 <a class="header-anchor" href="#朴素算法-改进版" aria-label="Permalink to &quot;朴素算法-改进版&quot;">​</a></h2><p>改进版的思想是先匹配第一个单词是否相等，如果相等则再比较后续的部分，Java的<code>String.contains()</code>方法就采用了这种思想</p><h3 id="代码解读-1" tabindex="-1">代码解读 <a class="header-anchor" href="#代码解读-1" aria-label="Permalink to &quot;代码解读&quot;">​</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#F47067;">public</span><span style="color:#F47067;"> int</span><span style="color:#DCBDFB;"> indexOf</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] content, </span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword) {</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> n</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> content.length, m </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> keyword.length;</span></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (n </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (m </span><span style="color:#F47067;">==</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    char</span><span style="color:#ADBAC7;"> first</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> keyword[</span><span style="color:#6CB6FF;">0</span><span style="color:#ADBAC7;">];</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> max</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> n </span><span style="color:#F47067;">-</span><span style="color:#ADBAC7;"> m;</span></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;=</span><span style="color:#ADBAC7;"> max; i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#768390;">        // 先看首字符想不想等</span></span>
<span class="line"><span style="color:#F47067;">        while</span><span style="color:#ADBAC7;"> (i </span><span style="color:#F47067;">&lt;=</span><span style="color:#ADBAC7;"> max </span><span style="color:#F47067;">&amp;&amp;</span><span style="color:#ADBAC7;"> content[i] </span><span style="color:#F47067;">!=</span><span style="color:#ADBAC7;"> first) {</span></span>
<span class="line"><span style="color:#ADBAC7;">            i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#768390;">        // 在看后面的想不想等</span></span>
<span class="line"><span style="color:#F47067;">        if</span><span style="color:#ADBAC7;"> (i </span><span style="color:#F47067;">&lt;=</span><span style="color:#ADBAC7;"> max) {</span></span>
<span class="line"><span style="color:#F47067;">            int</span><span style="color:#ADBAC7;"> j</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> i </span><span style="color:#F47067;">+</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#F47067;">            int</span><span style="color:#ADBAC7;"> end</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> i </span><span style="color:#F47067;">+</span><span style="color:#ADBAC7;"> m;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">            // j的范围在 [i+1, i+m) 之间</span></span>
<span class="line"><span style="color:#F47067;">            for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> k</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">; j </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> end; j</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">, k</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">                if</span><span style="color:#ADBAC7;"> (content[j] </span><span style="color:#F47067;">!=</span><span style="color:#ADBAC7;"> keyword[k]) {</span></span>
<span class="line"><span style="color:#F47067;">                    break</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">                }</span></span>
<span class="line"><span style="color:#ADBAC7;">            }</span></span>
<span class="line"><span style="color:#F47067;">            if</span><span style="color:#ADBAC7;"> (j </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> end) {</span></span>
<span class="line"><span style="color:#F47067;">                return</span><span style="color:#ADBAC7;"> i;</span></span>
<span class="line"><span style="color:#ADBAC7;">            }</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><h3 id="时间复杂度-1" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度-1" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><p>改进版相比原版，只是实现的逻辑略有不同，但是时间复杂度并没有任何提升：</p><ul><li>匹配单个keyword时间复杂度：O(m*n)</li><li>匹配k个keyword组成的词库时间复杂度：O(k*m*n)</li></ul><h2 id="字典树" tabindex="-1">字典树 <a class="header-anchor" href="#字典树" aria-label="Permalink to &quot;字典树&quot;">​</a></h2><p>又称<strong>前缀树</strong>或者<strong>Trie树</strong>，是一种树形结构，其思想是利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。目前内容安全就是采用该算法进行关键词的匹配</p><h3 id="特点-1" tabindex="-1">特点 <a class="header-anchor" href="#特点-1" aria-label="Permalink to &quot;特点&quot;">​</a></h3><p>优点：词库匹配的情况下时间复杂度较低 缺点：每次删除、修改关键词都需要全量build字典树</p><h3 id="演示-1" tabindex="-1">演示 <a class="header-anchor" href="#演示-1" aria-label="Permalink to &quot;演示&quot;">​</a></h3><p><img src="`+o+`" style="max-height:400px;" loading="lazy"></p><h3 id="代码解读-2" tabindex="-1">代码解读 <a class="header-anchor" href="#代码解读-2" aria-label="Permalink to &quot;代码解读&quot;">​</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#F47067;">class</span><span style="color:#F69D50;"> TrieNode</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> count; </span><span style="color:#768390;">//表示以该处节点构成的串的个数</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> preCount; </span><span style="color:#768390;">//表示以该处节点构成的前缀的字串的个数</span></span>
<span class="line"><span style="color:#ADBAC7;">    Map</span><span style="color:#F69D50;">&lt;</span><span style="color:#F47067;">Character</span><span style="color:#F69D50;">, </span><span style="color:#F47067;">TrieNode</span><span style="color:#F69D50;">&gt; </span><span style="color:#ADBAC7;">child;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCBDFB;">    TrieNode</span><span style="color:#ADBAC7;">() {</span></span>
<span class="line"><span style="color:#ADBAC7;">        child </span><span style="color:#F47067;">=</span><span style="color:#F47067;"> new</span><span style="color:#ADBAC7;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#ADBAC7;">        count </span><span style="color:#F47067;">=</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        preCount </span><span style="color:#F47067;">=</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#F47067;">class</span><span style="color:#F69D50;"> Trie</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">    TrieNode</span><span style="color:#ADBAC7;"> root;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    public</span><span style="color:#DCBDFB;"> Trie</span><span style="color:#ADBAC7;">() {</span></span>
<span class="line"><span style="color:#ADBAC7;">        root </span><span style="color:#F47067;">=</span><span style="color:#F47067;"> new</span><span style="color:#DCBDFB;"> TrieNode</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    public</span><span style="color:#F47067;"> void</span><span style="color:#DCBDFB;"> insert</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] </span><span style="color:#F69D50;">word</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        TrieNode</span><span style="color:#ADBAC7;"> node</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> root;</span></span>
<span class="line"><span style="color:#F47067;">        for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;"> ch</span><span style="color:#F47067;"> :</span><span style="color:#ADBAC7;"> word) {</span></span>
<span class="line"><span style="color:#768390;">            //计算下一个节点</span></span>
<span class="line"><span style="color:#ADBAC7;">            TrieNode</span><span style="color:#ADBAC7;"> next</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> node.child.</span><span style="color:#DCBDFB;">computeIfAbsent</span><span style="color:#ADBAC7;">(ch, oldV </span><span style="color:#F47067;">-&gt;</span><span style="color:#F47067;"> new</span><span style="color:#DCBDFB;"> TrieNode</span><span style="color:#ADBAC7;">());</span></span>
<span class="line"><span style="color:#768390;">            //node指向下一个节点</span></span>
<span class="line"><span style="color:#ADBAC7;">            node </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> next;</span></span>
<span class="line"><span style="color:#ADBAC7;">            node.preCount</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#ADBAC7;">        node.count</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    public</span><span style="color:#F47067;"> boolean</span><span style="color:#DCBDFB;"> search</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] </span><span style="color:#F69D50;">word</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        TrieNode</span><span style="color:#ADBAC7;"> node</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> root;</span></span>
<span class="line"><span style="color:#F47067;">        for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;"> ch</span><span style="color:#F47067;"> :</span><span style="color:#ADBAC7;"> word) {</span></span>
<span class="line"><span style="color:#ADBAC7;">            TrieNode</span><span style="color:#ADBAC7;"> next</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> node.child.</span><span style="color:#DCBDFB;">get</span><span style="color:#ADBAC7;">(ch);</span></span>
<span class="line"><span style="color:#F47067;">            if</span><span style="color:#ADBAC7;"> (next </span><span style="color:#F47067;">==</span><span style="color:#6CB6FF;"> null</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">                return</span><span style="color:#6CB6FF;"> false</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">            }</span></span>
<span class="line"><span style="color:#ADBAC7;">            node </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> next;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#ADBAC7;"> node.count </span><span style="color:#F47067;">&gt;</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    public</span><span style="color:#F47067;"> boolean</span><span style="color:#DCBDFB;"> startWith</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] </span><span style="color:#F69D50;">prefix</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        TrieNode</span><span style="color:#ADBAC7;"> node</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> root;</span></span>
<span class="line"><span style="color:#F47067;">        for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;"> ch</span><span style="color:#F47067;"> :</span><span style="color:#ADBAC7;"> prefix) {</span></span>
<span class="line"><span style="color:#ADBAC7;">            node </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> node.child.</span><span style="color:#DCBDFB;">computeIfAbsent</span><span style="color:#ADBAC7;">(ch, oldV </span><span style="color:#F47067;">-&gt;</span><span style="color:#F47067;"> new</span><span style="color:#DCBDFB;"> TrieNode</span><span style="color:#ADBAC7;">());</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#ADBAC7;"> node.preCount </span><span style="color:#F47067;">&gt;</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><h3 id="时间复杂度-2" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度-2" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><p>假设content长度为n，keyword长度为m，则：</p><ul><li>匹配单个keyword时间复杂度：O(n*log(m))</li><li>匹配<code>k</code>个关键词时间复杂度：O(n*log(k*m))</li></ul><h2 id="kmp算法" tabindex="-1">KMP算法 <a class="header-anchor" href="#kmp算法" aria-label="Permalink to &quot;KMP算法&quot;">​</a></h2><p>kmp算法是由大神高德纳参与发明的算法，其核心思想是利用匹配失败后的信息，尽量减少匹配次数以达到快速匹配的目的</p><h3 id="特点-2" tabindex="-1">特点 <a class="header-anchor" href="#特点-2" aria-label="Permalink to &quot;特点&quot;">​</a></h3><p>优点：next数组不依赖原文content，所以在<strong>管理时</strong>就可以计算生成，从而大大提升<strong>运行时</strong>的识别速度 缺点：next数组的代码逻辑理解比较困难</p><h3 id="演示-2" tabindex="-1">演示 <a class="header-anchor" href="#演示-2" aria-label="Permalink to &quot;演示&quot;">​</a></h3><p><img src="`+e+`" style="max-height:400px;" loading="lazy"></p><h3 id="代码解读-3" tabindex="-1">代码解读 <a class="header-anchor" href="#代码解读-3" aria-label="Permalink to &quot;代码解读&quot;">​</a></h3><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#F47067;">public</span><span style="color:#F47067;"> int</span><span style="color:#DCBDFB;"> kmp</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] content, </span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword) {</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> n</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> content.length, m </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> keyword.length;</span></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (n </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (m </span><span style="color:#F47067;">==</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">    //计算next数组</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#F69D50;">[] </span><span style="color:#ADBAC7;">next</span><span style="color:#F47067;"> =</span><span style="color:#DCBDFB;"> next</span><span style="color:#ADBAC7;">(keyword);</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> j</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> n; i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        while</span><span style="color:#ADBAC7;"> (j </span><span style="color:#F47067;">&gt;</span><span style="color:#6CB6FF;"> 0</span><span style="color:#F47067;"> &amp;&amp;</span><span style="color:#ADBAC7;"> content[i] </span><span style="color:#F47067;">!=</span><span style="color:#ADBAC7;"> keyword[j]) {</span></span>
<span class="line"><span style="color:#768390;">            //找到j的下一个位置</span></span>
<span class="line"><span style="color:#ADBAC7;">            j </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> next[j </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">];</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#F47067;">        if</span><span style="color:#ADBAC7;"> (content[i] </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> keyword[j]) {</span></span>
<span class="line"><span style="color:#ADBAC7;">            j</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#F47067;">        if</span><span style="color:#ADBAC7;"> (j </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> m) {</span></span>
<span class="line"><span style="color:#F47067;">            return</span><span style="color:#ADBAC7;"> i </span><span style="color:#F47067;">+</span><span style="color:#6CB6FF;"> 1</span><span style="color:#F47067;"> -</span><span style="color:#ADBAC7;"> j;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><p>了解next数组之前，需要先知道一个概念：<strong>最长公共前后缀</strong>，举个例子：对于字符串<code>&quot;ababa&quot;</code>,其前缀和后缀相同的情况分别为：</p><ul><li>前缀<code>&quot;a&quot;</code>，后缀<code>&quot;a&quot;</code></li><li>前缀<code>&quot;aba&quot;</code>，后缀<code>&quot;aba&quot;</code></li></ul><p>则我们称<code>&quot;aba&quot;</code>是字符串<code>&quot;ababa&quot;</code>的最长公共前后缀，<strong>next数组的本质就是在求字符串中的最大公共前后缀的长度</strong><code>next[i]</code>表示<code>keyword</code>字符串中<code>[0,i-1]</code>组成的子串，其最大公共前后缀的长度，比如对于一个关键词：<code>&quot;ababc&quot;</code>,<code>[0,3]</code>组成的子串是<code>&quot;abab&quot;</code>，其最大公共前后缀为<code>&quot;ab&quot;</code>,所以<code>next[3]=2</code> 根据<code>next</code>数组的规律，我们可以确定有如下的结论是成立的：<code>next[i]</code>的最大值为<code>next[i-1]+1</code></p><p><code>next</code>数组的实现采用了类似动态规划的思想，在求<code>next[i+1]</code>之前假设我们已经求得了<code>next[0]</code>...<code>next[i]</code>的值：</p><ol><li>假设<code>next[i]=k</code>，则有<code>a[0,k-1]=a[i-k+1,i]</code>（前<code>k-1</code>位字符与后<code>k-1</code>位字符重合，<code>数组a</code>表示<code>keyword</code>的字符数组）</li><li>如果<code>a[i+1]</code>=<code>a[k]</code>，则<code>a[0,k]</code>=<code>a[i-k+1,i+1]</code>，此时<code>next[i+1]</code>=<code>k+1</code>，否则进入下一步</li><li>再假设<code>next[k]</code>=<code>m</code>，则<code>a[0,m-1]</code>=<code>a[k-m+1,k-1]</code>，</li><li>联合1、3步可以得到：<code>a[0,m-1]</code>=<code>a[k-m+1,k-1]</code>=<code>a[i-k+1,i-k+1+m]</code>=<code>a[i-m+1,i]</code>这四段都重合</li><li>这时再判断，如果<code>a[i+1]</code>=<code>a[m]</code>，则<code>a[0,m]</code>=<code>a[i-m+1,i+1]</code>，此时<code>next[i+1]</code>=<code>m+1</code>,否则再取<code>next[m]</code>=<code>n</code>,以此类推</li></ol><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#F47067;">public</span><span style="color:#F47067;"> int</span><span style="color:#ADBAC7;">[] </span><span style="color:#DCBDFB;">next</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword) {</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#F69D50;">[] </span><span style="color:#ADBAC7;">next</span><span style="color:#F47067;"> =</span><span style="color:#F47067;"> new</span><span style="color:#F47067;"> int</span><span style="color:#ADBAC7;">[keyword.length];</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> j</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> keyword.length; i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        while</span><span style="color:#ADBAC7;"> (j </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> i </span><span style="color:#F47067;">&amp;&amp;</span><span style="color:#ADBAC7;"> j </span><span style="color:#F47067;">&gt;</span><span style="color:#6CB6FF;"> 0</span><span style="color:#F47067;"> &amp;&amp;</span><span style="color:#ADBAC7;"> keyword[i] </span><span style="color:#F47067;">!=</span><span style="color:#ADBAC7;"> keyword[j]) {</span></span>
<span class="line"><span style="color:#768390;">            //j取下一个理想位置</span></span>
<span class="line"><span style="color:#ADBAC7;">            j </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> next[j </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">];</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#F47067;">        if</span><span style="color:#ADBAC7;"> (keyword[i] </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> keyword[j]) {</span></span>
<span class="line"><span style="color:#ADBAC7;">            j</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">            next[i] </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> j;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#ADBAC7;"> next;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><h3 id="时间复杂度-3" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度-3" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><p>假设content长度为m，keyword长度为n，则：</p><ul><li>next数组的构建时间复杂度为：$O(m)$</li><li>匹配单个keyword时间复杂度：$O(m+n)$</li></ul><h2 id="bm算法" tabindex="-1">BM算法 <a class="header-anchor" href="#bm算法" aria-label="Permalink to &quot;BM算法&quot;">​</a></h2><p>Boyer-Moore算法由Bob Boyer和J Strother Moore设计于1977年。一般情况下，比KMP算法快3-5倍。该算法常用于文本编辑器中的搜索匹配功能，比如大家所熟知的grep命令使用的就是该算法。</p><h3 id="特点-3" tabindex="-1">特点 <a class="header-anchor" href="#特点-3" aria-label="Permalink to &quot;特点&quot;">​</a></h3><p>优点：应用广泛，匹配时间快 缺点：代码复杂，不容易理解</p><h3 id="演示-3" tabindex="-1">演示 <a class="header-anchor" href="#演示-3" aria-label="Permalink to &quot;演示&quot;">​</a></h3><p><img src="`+c+'" style="max-height:400px;" loading="lazy"></p><h3 id="代码解读-4" tabindex="-1">代码解读 <a class="header-anchor" href="#代码解读-4" aria-label="Permalink to &quot;代码解读&quot;">​</a></h3><h4 id="坏字符规则" tabindex="-1">坏字符规则 <a class="header-anchor" href="#坏字符规则" aria-label="Permalink to &quot;坏字符规则&quot;">​</a></h4><p>BM 算法是从后往前进行比较，我们来看一下具体过程，假设有原文为<code>&quot;HERE IS A SIMPLE EXAMPLE&quot;</code>，关键词为<code>&quot;EXAMPLE</code>&quot;：</p><p><img src="'+t+'" style="max-height:400px;" loading="lazy"></p><p>此时<code>&quot;S&quot;</code>与<code>&quot;E&quot;</code>不匹配，<code>&quot;S&quot;</code>就被称为 <strong>&quot;坏字符&quot;</strong> ，即不匹配的字符。我们还发现<code>&quot;S&quot;</code>不包含在关键词<code>&quot;EXAMPLE&quot;</code>之中，这意味着可以把关键词直接移到<code>&quot;S&quot;</code>的后一位。</p><p><img src="'+r+`" style="max-height:400px;" loading="lazy"></p><p>依然从尾部开始比较，发现<code>&quot;P&quot;</code>与<code>&quot;E&quot;</code>不匹配，所以<code>&quot;P&quot;</code>是 <strong>&quot;坏字符&quot;</strong> 。但是，<code>&quot;P&quot;</code>包含在搜索词<code>&quot;EXAMPLE&quot;</code>之中。所以将搜索词后移两位，两个<code>&quot;P&quot;</code>对齐。 因此不难得出 <strong>&quot;坏字符&quot;</strong> 的规则：<code>后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置</code></p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#768390;">// 坏字符规则表</span></span>
<span class="line"><span style="color:#F47067;">private</span><span style="color:#F47067;"> int</span><span style="color:#ADBAC7;">[] </span><span style="color:#DCBDFB;">buildBadCharacter</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword) {</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> m</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> keyword.length;</span></span>
<span class="line"><span style="color:#F47067;">    final</span><span style="color:#F47067;"> int</span><span style="color:#ADBAC7;"> CHARACTER_SIZE</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 256</span><span style="color:#ADBAC7;">; </span><span style="color:#768390;">// 英文字符的种类，2^8</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#F69D50;">[] </span><span style="color:#ADBAC7;">badChar</span><span style="color:#F47067;"> =</span><span style="color:#F47067;"> new</span><span style="color:#F47067;"> int</span><span style="color:#ADBAC7;">[CHARACTER_SIZE]; </span><span style="color:#768390;">// 记录坏字符出现时后移位数</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">    // 默认后移整个模式串长度</span></span>
<span class="line"><span style="color:#ADBAC7;">    Arrays.</span><span style="color:#DCBDFB;">fill</span><span style="color:#ADBAC7;">(badChar, m);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">; i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        int</span><span style="color:#ADBAC7;"> ascii</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> keyword[i];  </span><span style="color:#768390;">// 当前字符对应的ASCII值</span></span>
<span class="line"><span style="color:#ADBAC7;">        badChar[ascii] </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#F47067;"> -</span><span style="color:#ADBAC7;"> i;   </span><span style="color:#768390;">// 对应的后移位数，若重复则以最右边为准</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#ADBAC7;"> badChar;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><h4 id="好后缀规则" tabindex="-1">好后缀规则 <a class="header-anchor" href="#好后缀规则" aria-label="Permalink to &quot;好后缀规则&quot;">​</a></h4><ol><li><p>依然从尾部开始比较，<code>&quot;E&quot;</code>与<code>&quot;E&quot;</code>匹配：</p><p><img src="`+y+'" style="max-height:400px;" loading="lazy"></p></li><li><p>比较前面一位，<code>&quot;LE&quot;</code>与<code>&quot;LE&quot;</code>匹配：</p><p><img src="'+A+'" style="max-height:400px;" loading="lazy"></p></li><li><p>比较前面一位，&quot;PLE&quot;与&quot;PLE&quot;匹配：</p><p><img src="'+i+'" style="max-height:400px;" loading="lazy"></p></li><li><p>比较前面一位，&quot;MPLE&quot;与&quot;MPLE&quot;匹配：</p><p><img src="'+C+'" style="max-height:400px;" loading="lazy"></p></li><li><p>我们把这种情况称为 <strong>&quot;好后缀&quot;</strong> ，<code>&quot;MPLE&quot;</code>、<code>&quot;PLE&quot;</code>、<code>&quot;LE&quot;</code>、<code>&quot;E&quot;</code>都是好后缀。</p></li><li><p>所有的 <strong>&quot;好后缀&quot;</strong> 之中，只有<code>&quot;E&quot;</code>在<code>&quot;EXAMPLE&quot;</code>中还出现在头部，所以后移 6位：</p><p><img src="'+B+`" style="max-height:400px;" loading="lazy"></p></li></ol><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#768390;">// 好前缀规则表</span></span>
<span class="line"><span style="color:#F47067;">private</span><span style="color:#F47067;"> int</span><span style="color:#ADBAC7;">[] </span><span style="color:#DCBDFB;">buildGoodSuffix</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword) {</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> m</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> keyword.length;</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#F69D50;">[] </span><span style="color:#ADBAC7;">goodSuffix</span><span style="color:#F47067;"> =</span><span style="color:#F47067;"> new</span><span style="color:#F47067;"> int</span><span style="color:#ADBAC7;">[m];   </span><span style="color:#768390;">// 记录好后缀出现时后移位数</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> lastPrefixPos</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> m;   </span><span style="color:#768390;">// 好后缀的首字符位置</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&gt;=</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">; i</span><span style="color:#F47067;">--</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        if</span><span style="color:#ADBAC7;"> (</span><span style="color:#DCBDFB;">isPrefix</span><span style="color:#ADBAC7;">(keyword, i </span><span style="color:#F47067;">+</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">)) {</span></span>
<span class="line"><span style="color:#768390;">            //如果当前的位置存在前缀匹配，那么记录当前位置</span></span>
<span class="line"><span style="color:#ADBAC7;">            lastPrefixPos </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> i </span><span style="color:#F47067;">+</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#768390;">        // 如果是好后缀，则goodSuffix=m，否则依次为m+1、m+2、...</span></span>
<span class="line"><span style="color:#ADBAC7;">        goodSuffix[m </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#F47067;"> -</span><span style="color:#ADBAC7;"> i] </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> lastPrefixPos </span><span style="color:#F47067;">-</span><span style="color:#ADBAC7;"> i </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#F47067;"> +</span><span style="color:#ADBAC7;"> m;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">; i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#768390;">        //计算出指定位置匹配的后缀的字符串长度</span></span>
<span class="line"><span style="color:#F47067;">        int</span><span style="color:#ADBAC7;"> length</span><span style="color:#F47067;"> =</span><span style="color:#DCBDFB;"> suffixLength</span><span style="color:#ADBAC7;">(keyword, i);</span></span>
<span class="line"><span style="color:#ADBAC7;">        goodSuffix[length] </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#F47067;"> -</span><span style="color:#ADBAC7;"> i </span><span style="color:#F47067;">+</span><span style="color:#ADBAC7;"> length;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#ADBAC7;"> goodSuffix;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">// 前缀匹配</span></span>
<span class="line"><span style="color:#F47067;">private</span><span style="color:#F47067;"> boolean</span><span style="color:#DCBDFB;"> isPrefix</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword, </span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> start) {</span></span>
<span class="line"><span style="color:#768390;">    //这里j从关键词第一个字符开始，i从start位置开始，通过循环判断start之后的字符串是否匹配关键词前缀</span></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> start, j </span><span style="color:#F47067;">=</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> keyword.length; i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">, j</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        if</span><span style="color:#ADBAC7;"> (keyword[i] </span><span style="color:#F47067;">!=</span><span style="color:#ADBAC7;"> keyword[j]) {</span></span>
<span class="line"><span style="color:#F47067;">            return</span><span style="color:#6CB6FF;"> false</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#6CB6FF;"> true</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">// 后缀匹配</span></span>
<span class="line"><span style="color:#F47067;">private</span><span style="color:#F47067;"> int</span><span style="color:#DCBDFB;"> suffixLength</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword, </span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> start) {</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> length</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> start;</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> j</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> keyword.length </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#F47067;">    while</span><span style="color:#ADBAC7;"> (i </span><span style="color:#F47067;">&gt;=</span><span style="color:#6CB6FF;"> 0</span><span style="color:#F47067;"> &amp;&amp;</span><span style="color:#ADBAC7;"> keyword[i] </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> keyword[j]) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        length</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        i</span><span style="color:#F47067;">--</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        j</span><span style="color:#F47067;">--</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#ADBAC7;"> length;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><h4 id="匹配代码" tabindex="-1">匹配代码 <a class="header-anchor" href="#匹配代码" aria-label="Permalink to &quot;匹配代码&quot;">​</a></h4><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#F47067;">public</span><span style="color:#F47067;"> int</span><span style="color:#DCBDFB;"> bm</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] content, </span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword) {</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> n</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> content.length, m </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> keyword.length;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (n </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (m </span><span style="color:#F47067;">==</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#F69D50;">[] </span><span style="color:#ADBAC7;">badChar</span><span style="color:#F47067;"> =</span><span style="color:#DCBDFB;"> buildBadCharacter</span><span style="color:#ADBAC7;">(keyword);</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#F69D50;">[] </span><span style="color:#ADBAC7;">goodSuffix</span><span style="color:#F47067;"> =</span><span style="color:#DCBDFB;"> buildGoodSuffix</span><span style="color:#ADBAC7;">(keyword);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">    // 从尾部开始匹配</span></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> n; ) {</span></span>
<span class="line"><span style="color:#F47067;">        int</span><span style="color:#ADBAC7;"> j</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#F47067;">        while</span><span style="color:#ADBAC7;"> (content[i] </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> keyword[j]) {</span></span>
<span class="line"><span style="color:#F47067;">            if</span><span style="color:#ADBAC7;"> (j </span><span style="color:#F47067;">==</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#768390;">                // 匹配成功</span></span>
<span class="line"><span style="color:#F47067;">                return</span><span style="color:#ADBAC7;"> i;</span></span>
<span class="line"><span style="color:#ADBAC7;">            }</span></span>
<span class="line"><span style="color:#ADBAC7;">            i</span><span style="color:#F47067;">--</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">            j</span><span style="color:#F47067;">--</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#768390;">        // 每次后移&quot;坏字符”和“好后缀” </span></span>
<span class="line"><span style="color:#ADBAC7;">        i </span><span style="color:#F47067;">+=</span><span style="color:#ADBAC7;"> Math.</span><span style="color:#DCBDFB;">max</span><span style="color:#ADBAC7;">(badChar[content[i]], goodSuffix[m </span><span style="color:#F47067;">-</span><span style="color:#6CB6FF;"> 1</span><span style="color:#F47067;"> -</span><span style="color:#ADBAC7;"> j]);</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><h3 id="时间复杂度-4" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度-4" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><p>假设content长度为n，keyword长度为m，则：</p><ul><li>匹配单个keyword平均时间复杂度为O(n)</li><li>最坏情况下的时间复杂度为O(m*n)</li></ul><h2 id="sunday算法" tabindex="-1">Sunday算法 <a class="header-anchor" href="#sunday算法" aria-label="Permalink to &quot;Sunday算法&quot;">​</a></h2><p>Sunday算法借鉴了BM算法的坏字符规则，不过和BM算法不同的是，Sunday算法是从前往后匹配的。</p><h3 id="特点-4" tabindex="-1">特点 <a class="header-anchor" href="#特点-4" aria-label="Permalink to &quot;特点&quot;">​</a></h3><p>优点：代码简单容易理解，时间复杂度低 缺点：算法不稳定，最坏情况下时间复杂度和朴素算法一致</p><h3 id="演示-4" tabindex="-1">演示 <a class="header-anchor" href="#演示-4" aria-label="Permalink to &quot;演示&quot;">​</a></h3><p><img src="`+F+`" style="max-height:400px;" loading="lazy"></p><h3 id="代码解读-5" tabindex="-1">代码解读 <a class="header-anchor" href="#代码解读-5" aria-label="Permalink to &quot;代码解读&quot;">​</a></h3><p>Sunday算法<strong>在匹配失败时重点关注的是关键词中参加匹配的最末位字符的下一位</strong>：</p><ul><li>如果该字符<strong>没有在原文中出现则直接跳过</strong>，即<code>移动位数 = 关键词长度 + 1</code></li><li>否则，其<code>移动位数 = 原文长度 - 该字符最右出现的位置</code></li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code"><code><span class="line"><span style="color:#F47067;">public</span><span style="color:#F47067;"> int</span><span style="color:#DCBDFB;"> sunday</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] content, </span><span style="color:#F47067;">char</span><span style="color:#ADBAC7;">[] keyword) {</span></span>
<span class="line"><span style="color:#F47067;">    int</span><span style="color:#ADBAC7;"> n</span><span style="color:#F47067;"> =</span><span style="color:#ADBAC7;"> content.length, m </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> keyword.length;</span></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (n </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    if</span><span style="color:#ADBAC7;"> (m </span><span style="color:#F47067;">==</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#F47067;">        return</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#768390;">    // 构造偏移表</span></span>
<span class="line"><span style="color:#ADBAC7;">    Map</span><span style="color:#F69D50;">&lt;</span><span style="color:#F47067;">Character</span><span style="color:#F69D50;">, </span><span style="color:#F47067;">Integer</span><span style="color:#F69D50;">&gt; </span><span style="color:#ADBAC7;">map</span><span style="color:#F47067;"> =</span><span style="color:#F47067;"> new</span><span style="color:#ADBAC7;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m; i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        map.</span><span style="color:#DCBDFB;">put</span><span style="color:#ADBAC7;">(keyword[i], m </span><span style="color:#F47067;">-</span><span style="color:#ADBAC7;"> i);</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">    for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> i</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;=</span><span style="color:#ADBAC7;"> n </span><span style="color:#F47067;">-</span><span style="color:#ADBAC7;"> m; ) {</span></span>
<span class="line"><span style="color:#F47067;">        int</span><span style="color:#ADBAC7;"> j</span><span style="color:#F47067;"> =</span><span style="color:#6CB6FF;"> 0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#F47067;">        while</span><span style="color:#ADBAC7;"> (j </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">&amp;&amp;</span><span style="color:#ADBAC7;"> content[i </span><span style="color:#F47067;">+</span><span style="color:#ADBAC7;"> j] </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> keyword[j]) {</span></span>
<span class="line"><span style="color:#ADBAC7;">            j</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#F47067;">        if</span><span style="color:#ADBAC7;"> (j </span><span style="color:#F47067;">==</span><span style="color:#ADBAC7;"> m) {</span></span>
<span class="line"><span style="color:#F47067;">            return</span><span style="color:#ADBAC7;"> i;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#F47067;">        if</span><span style="color:#ADBAC7;"> (i </span><span style="color:#F47067;">+</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> n) {</span></span>
<span class="line"><span style="color:#ADBAC7;">            i </span><span style="color:#F47067;">+=</span><span style="color:#ADBAC7;"> map.</span><span style="color:#DCBDFB;">computeIfAbsent</span><span style="color:#ADBAC7;">(content[i </span><span style="color:#F47067;">+</span><span style="color:#ADBAC7;"> m], key </span><span style="color:#F47067;">-&gt;</span><span style="color:#ADBAC7;"> m </span><span style="color:#F47067;">+</span><span style="color:#6CB6FF;"> 1</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        } </span><span style="color:#F47067;">else</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#F47067;">            return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#F47067;">    return</span><span style="color:#F47067;"> -</span><span style="color:#6CB6FF;">1</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre></div><h3 id="时间复杂度-5" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度-5" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><p>假设content长度为m，keyword长度为n，则：</p><ul><li>匹配单个keyword平均时间复杂度：O(m/n)</li><li>匹配单个keyword最坏情况的时间复杂度为：O(m*n)</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>本文介绍了下常见几种关键词匹配算法，每种算法都有其适用的场景，比如朴素算法，因为代码简单，容易理解，因此被java的contains方法所采用；像关键词数量远大于原文的情况下，字段树就非常适合；如果关键词很小，而原文非常长，bm算法就非常适合。希望这边文章能对大家有所帮助。</p>`,91),h=[d];function u(m,k,g,q,b,f){return a(),n("div",null,h)}const j=s(D,[["render",u]]);export{w as __pageData,j as default};
