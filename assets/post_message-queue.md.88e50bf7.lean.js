import{_ as d,c as o,b as t,e as i,d as e,a as r,r as n,o as l}from"./app.46b62a4d.js";const W=JSON.parse('{"title":"你真的了解消息队列吗","description":"","frontmatter":{"title":"你真的了解消息队列吗","date":"2022-11-11T00:00:00.000Z","excerpt":"一篇文章带你探寻消息队列的几个基础功能的原理","tags":["mq","消息队列","kafka","time wheel"]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"术语","slug":"术语","link":"#术语","children":[{"level":3,"title":"基础","slug":"基础","link":"#基础","children":[]},{"level":3,"title":"消息类型","slug":"消息类型","link":"#消息类型","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]},{"level":2,"title":"消费模式","slug":"消费模式","link":"#消费模式","children":[{"level":3,"title":"拉模式（pull）","slug":"拉模式-pull","link":"#拉模式-pull","children":[]},{"level":3,"title":"推模式（push）","slug":"推模式-push","link":"#推模式-push","children":[]}]},{"level":2,"title":"消息队列选型速览","slug":"消息队列选型速览","link":"#消息队列选型速览","children":[]},{"level":2,"title":"投递&消费语义","slug":"投递-消费语义","link":"#投递-消费语义","children":[{"level":3,"title":"投递语义","slug":"投递语义","link":"#投递语义","children":[]},{"level":3,"title":"消费语义","slug":"消费语义","link":"#消费语义","children":[]}]},{"level":2,"title":"功能特性","slug":"功能特性","link":"#功能特性","children":[{"level":3,"title":"事务消息","slug":"事务消息","link":"#事务消息","children":[]},{"level":3,"title":"延迟消息","slug":"延迟消息","link":"#延迟消息","children":[]},{"level":3,"title":"顺序消息","slug":"顺序消息","link":"#顺序消息","children":[]},{"level":3,"title":"消息轨迹","slug":"消息轨迹","link":"#消息轨迹","children":[]}]},{"level":2,"title":"稳定性&性能","slug":"稳定性-性能","link":"#稳定性-性能","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"relativePath":"post/message-queue.md","lastUpdated":1673363559000}'),s={name:"post/message-queue.md"},c=t("h1",{id:"你真的了解消息队列吗",tabindex:"-1"},[e("你真的了解消息队列吗 "),t("a",{class:"header-anchor",href:"#你真的了解消息队列吗","aria-hidden":"true"},"#")],-1),h=r("",12),p=r("",26),u=r("",11),g={start:"2"},m=r("",1),_=t("p",null,[t("strong",null,"总结")],-1),b=t("ul",null,[t("li",null,"Kafka 使用时间轮来实现延时队列，因为其底层是任务的添加和删除是基于链表实现的，是 O(1) 的时间复杂度，满足高性能的要求"),t("li",null,"DelayQueue 只存放了 TimerTaskList，并不是所有的 TimerTask，数量并不多，相比空推进带来的影响是利大于弊的"),t("li",null,"对于时间跨度大的延时任务，Kafka 引入了层级时间轮，能更好控制时间粒度，可以应对更加复杂的定时任务处理场景")],-1),f=t("h6",{id:"rocketmq内部版",tabindex:"-1"},[e("rocketmq内部版 "),t("a",{class:"header-anchor",href:"#rocketmq内部版","aria-hidden":"true"},"#")],-1),k=t("p",null,"rocketmq在kafka的时间轮基础上提供了延迟消息可靠的存储方式",-1),y=t("li",null,[t("p",null,"时间轮的每一格设计如下"),t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"delay_time(8B) 延迟时间"),t("th",null,"first_pos 首条位置"),t("th",null,"last_pos(8B) 最后位置"),t("th",null,"num(4B) 消息条数")])])])],-1),T=t("li",null,[t("p",null,"TimerLog，定时消息的记录文件，Append Only。每条记录包含一个prev_pos，指向前一条定时到同样时刻的记录")],-1),x=t("ol",null,[t("li",null,[e("针对放置定时消息的service，每50ms从commitLog读取指定topic的定时消息 "),t("ol",null,[t("li",null,"TimerEnqueueGetService从commitLog读取得到定时主题的消息，并先将其放入enqueuePutQueue"),t("li",null,"另一个线程TimerEnqueuePutService将其放入timerLog,更新时间轮的存储内容。将该任务放进时间轮的指定位置")])]),t("li",null,[e("针对取出定时消息的service，每50ms读取下一秒的slot。有三个线程将读取到的消息重新放回commitLog "),t("ol",null,[t("li",null,"首先，TimerDequeueGetService每50ms读一次下一秒的slot，从timerLog中得到指定的msgs，并放进dequeueGetQueue"),t("li",null,"而后TimerDequeueGetMessageService从dequeueGetQueue中取出msg，并将其放入队列中。该队列为待写入commitLog的队列，dequeuePutQueue"),t("li",null,"最后TimerDequeuePutMessageService将这个queue中的消息取出，若已到期则修改topic，放回commitlog，否则继续按原topic写回CommitLog滚动")])])],-1),I=r("",12),C=t("h3",{id:"消息轨迹",tabindex:"-1"},[e("消息轨迹 "),t("a",{class:"header-anchor",href:"#消息轨迹","aria-hidden":"true"},"#")],-1),S=t("p",null,"一条消息的生命周期包含多个阶段：发送端发送，服务端收到消息、写入消息、投递消息等。而用户在使用MQ时，有时会想知道消息的发送、投递、消费情况，以及消费耗时、消费节点、是否重投等信息。这些信息都属于消息轨迹。 在没有可视化的消息轨迹界面时，轨迹信息都是通过原始的翻日志的方式来查询。需要根据机器节点的日志信息找到链路，一步一步溯源查找。",-1),q=r("",7),A=t("h5",{id:"消费一致性",tabindex:"-1"},[e("消费一致性 "),t("a",{class:"header-anchor",href:"#消费一致性","aria-hidden":"true"},"#")],-1),P=t("h4",{id:"高性能",tabindex:"-1"},[e("高性能 "),t("a",{class:"header-anchor",href:"#高性能","aria-hidden":"true"},"#")],-1),z=t("h5",{id:"零拷贝",tabindex:"-1"},[e("零拷贝 "),t("a",{class:"header-anchor",href:"#零拷贝","aria-hidden":"true"},"#")],-1),B=t("h5",{id:"磁盘顺序读写",tabindex:"-1"},[e("磁盘顺序读写 "),t("a",{class:"header-anchor",href:"#磁盘顺序读写","aria-hidden":"true"},"#")],-1),v=t("h4",{id:"msgbroker",tabindex:"-1"},[e("msgbroker "),t("a",{class:"header-anchor",href:"#msgbroker","aria-hidden":"true"},"#")],-1),D=t("h4",{id:"rocketmq",tabindex:"-1"},[e("rocketmq "),t("a",{class:"header-anchor",href:"#rocketmq","aria-hidden":"true"},"#")],-1),L=t("h5",{id:"_1-逻辑分区",tabindex:"-1"},[e("1. 逻辑分区 "),t("a",{class:"header-anchor",href:"#_1-逻辑分区","aria-hidden":"true"},"#")],-1),j=t("h5",{id:"_2-持久化",tabindex:"-1"},[e("2. 持久化 "),t("a",{class:"header-anchor",href:"#_2-持久化","aria-hidden":"true"},"#")],-1),M=r("",4),O=r("",5);function w(Q,E,N,V,R,H){const a=n("q-img");return l(),o("div",null,[c,t("p",null,[i(a,{src:"/post/message-queue/intro.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),h,t("p",null,[i(a,{src:"/post/message-queue/pull&push.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),p,t("p",null,[i(a,{src:"/post/message-queue/shiwu.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),u,t("p",null,[i(a,{src:"/post/message-queue/shijianlun1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),t("ol",g,[t("li",null,[e("假设初始的时候一个格子一秒，时间轮的指针定格在0。此时添加一个超时时间为2ms的任务, 那么这个任务将会插入到第二个时间格中 "),i(a,{src:"/post/message-queue/shijianlun2.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),t("li",null,[e("时间轮的指针到达第二个时间格时, 会处理该时间格上对应的任务 "),i(a,{src:"/post/message-queue/shijianlun3.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),t("li",null,[e("如果这个时候又插入一个延时时间为8ms的任务进来, 这个任务的过期时间就是在当前时间2ms的基础上加8ms, 也就是10ms, 那么这个任务将会插入到过期时间为10ms的时间格中。 "),i(a,{src:"/post/message-queue/shijianlun4.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),t("li",null,[e("如果在当前时间是2ms的时候, 插入一个延时时间为19ms的任务时, 这个任务的过期时间就是在当前时间2s的基础上加19ms, 也就是21ms，那么这个任务就会插入到过期时间为21ms的时间格中 "),i(a,{src:"/post/message-queue/shijianlun5.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),t("li",null,[e("如果在当前时间是2ms的时候, 插入一个延时时间为22ms的任务, 这个任务的过期时间就是在2ms的基础上加22ms，也就是24ms，但是显然没有24ms的格子 "),i(a,{src:"/post/message-queue/shijianlun6.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),t("li",null,[e("第一层的时间轮装不下的时候，任务就会放入第二层的时间轮格子中 "),i(a,{src:"/post/message-queue/shijianlun7.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),t("li",null,[e("当第二层时间轮上的任务到期后，就会执行时间轮的降级，原本超时时间为24ms的任务会被从第二层取出来，放入第一层到期时间为24ms的格子中 "),i(a,{src:"/post/message-queue/shijianlun8.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),t("li",null,[e("从这里可以看出时间轮的巧妙之处，两层时间轮只用了40个数组元素，却可以承载[0-399s]的定时任务。而三层时间轮用60个数组元素，就可以承载[0-7999s] 的定时任务 "),i(a,{src:"/post/message-queue/shijianlun9.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),m]),_,b,f,k,t("ol",null,[y,T,t("li",null,[t("p",null,[e("TimerLog与TimerWheel的协作如下图所示 "),i(a,{src:"/post/message-queue/r_shijianlun1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),t("li",null,[t("p",null,[e("消息的存储工作流程如下： "),i(a,{src:"/post/message-queue/r_shijianlun1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),x])]),I,t("p",null,[i(a,{src:"/post/message-queue/shunxu.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),C,S,t("p",null,[i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667220447378-24e397ad-a285-40dd-9047-88803459af4a.png#clientId=ud471318f-e47b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1455&id=u7ee5a91b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1455&originWidth=2971&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149879&status=done&style=none&taskId=u3841ca9f-2858-4740-8fd8-585f899378c&title=&width=2971",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),e(" 既然把消息轨迹当成消息存储在Broker服务器，那存储消息轨迹的Topic如何确定呢？RocketMQ提供了两种方法来定义消息轨迹的Topic。")]),q,t("p",null,[i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/__puml/e43f0a1abf02d76ab7097deea0187b2d.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJzZW5kZXIgLT4gYnJva2VyXG5icm9rZXIgLT4gZGIgOiBzYXZlIG1zZ1xuYnJva2VyIC0tPiBzZW5kZXIgOiBhY2svbmFja1xuYnJva2VyIC0-IHJlY2VpdmVyXG5yZWNlaXZlciAtLT4gYnJva2VyIDogYWNrL25hY2tcbmJyb2tlciAtPiBkYiA6IGRlbGV0ZSBtc2ciLCJ1cmwiOiJodHRwczovL2ludHJhbmV0cHJveHkuYWxpcGF5LmNvbS9za3lsYXJrL2xhcmsvX19wdW1sL2U0M2YwYTFhYmYwMmQ3NmFiNzA5N2RlZWEwMTg3YjJkLnN2ZyIsImlkIjoiYm1QU0IiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),e("##### 数据备份和故障转移 "),i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666871933931-97904c34-ab95-4778-9266-8a724d652213.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=ue475ed04&margin=%5Bobject%20Object%5D&name=image.png&originHeight=483&originWidth=1037&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59699&status=done&style=none&taskId=u85dd854e-7f54-4fe9-8d6c-addca350b18&title=&width=518.5",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),A,t("p",null,[i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666873658825-a41e31e0-f7dd-44e7-910c-f1a497841dd2.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=153&id=ubf45f24c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=306&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=155906&status=done&style=none&taskId=ud3f002cb-af85-4049-9add-af69a19790c&title=&width=540",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),e(" LogEndOffset：每个partition的log最后一条Message的位置。 HighWatermark：取最小LEO，consumer能够看到的此partition的位置。")]),P,z,t("p",null,[i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666874105184-a225b43d-bbc7-4cea-8f4f-cb05291be5c7.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=432&id=ucafb9bc6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=863&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=189782&status=done&style=none&taskId=uac12c40c-6569-448a-8259-d74addcb9f2&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666874115020-9996005b-36a2-4f0a-8051-824c5dd11908.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=427&id=u415102c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=853&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=183715&status=done&style=none&taskId=u05425056-2410-46d7-81fa-5cea881538c&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),B,t("p",null,[i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666874264460-8cbf0497-6148-4bea-bf87-49a800ef3d51.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=264&id=u655e9fe8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=646&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113276&status=done&style=none&taskId=u89e9f7da-7792-4ca4-b578-3412e933ab6&title=&width=323",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),v,t("p",null,[i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1666927224363-d5f358d6-4c94-4714-999a-d247de701a1b.png#clientId=ue9277cdc-a3a4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=357&id=u919d22b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=357&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74259&status=done&style=none&taskId=u7baec6c9-8d01-4648-8a19-0f428f8915e&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),e(" 在2.0的模型中将normal message table拆分为了多个表，并且在逻辑上组成了一个环，按照时间进行写入表的切换，并且定期批量的进行过期表中的数据删除。消息投递之后只会记录 checkpoint，标记哪些消息已经可以删除了，而不会真正执行 normal message table 中的数据删除，从而避免了频繁的插入和删除操作。可以简单的理解为2.0的模型写入就是不断的 Append 消息（checkpoint 可以理解为 offset），投递就是不断的推进checkpoint，删除是批量的对过期的表（不再进行读写）进行删除。")]),t("p",null,[i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1666755832767-cae32c00-2718-4c29-b71e-1ef860b3eb73.png#clientId=u33216851-4002-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=606&id=u16911af2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=757&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=314793&status=done&style=none&taskId=u5872799b-7230-4dd4-b8c1-db8cc3cd08e&title=&width=1200",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),e(" MsgBroker 2.0的计算模型设计中采用了全异步的模型，对各个开销较高的操作都做了异步化，比如msg-write-threads（消息写入线程池）仅负责消息写入时的业务逻辑，并不处理持久化操作。持久化操作是耗时的，由msg-flush-threads批量进行持久化，这样能使 msg-write-threads 更快的去处理更多的写入请求。基于这样的设计，能对各个阶段不同的线程池做精细化的配置，提升资源利用率和整体的性能。")]),D,t("p",null,[i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667303564561-2f07e1f6-7659-42fd-af1c-e6158b2b660d.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=540&id=u0afcf2aa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=540&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=151090&status=done&style=none&taskId=u69fe3af1-8ba5-496f-b9cd-2e6f00ec9b2&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),L,t("p",null,[e("为了提升整体的吞吐量与提供跨副本组的高可用能力，RocketMQ 服务端一般会为单个 Topic 创建多个逻辑分区，即在多个副本组上各自维护部分分区 ( Partition)，我们把它称为队列 (MessageQueue)。同一个副本组上同一个 Topic 的队列数相同并从 0 开始连续编号，不同副本组上的 MessageQueue 数量可以不同。 "),i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667211128802-1ebe1226-c430-4b6b-a95b-64ae84602146.png#clientId=u732f2838-f0ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=610&id=u13a63bf6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=217091&status=done&style=none&taskId=u1a163547-d3c6-45a3-bacb-68c9b9605a3&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),e(" 每个Topic在Broker上会划分成几个逻辑队列，每个逻辑队列保存一部分消息数据。从上面模型可以看出，要解决消费并发，就是要利用Queue,一个Topic可以分出更多的queue,每一个queue可以存放在不同的硬件上来提高并发。")]),j,t("p",null,[e("在RocketMQ中消息刷盘主要可以分为同步刷盘和异步刷盘两种。 "),i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667301973880-fbab5567-a642-42b6-8ead-7fa8e666e23d.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=540&id=u5e5e4647&margin=%5Bobject%20Object%5D&name=image.png&originHeight=908&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48292&status=done&style=none&taskId=u1e3a47a0-19e3-4baa-b8f2-559591abd3e&title=&width=347",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),e(" 消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。")]),t("p",null,[i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667302024113-a2ca21dc-b78c-4e84-a005-2a84c19c0f75.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=592&id=ud39bf6fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=906&originWidth=542&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49898&status=done&style=none&taskId=uc5830126-bfa6-4900-9880-40955d7f100&title=&width=354",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),e(" 在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘操作，快速写入。")]),M,t("p",null,[e("批量消息是指将多条小的消息合并成一个批量消息，一次发送出去。这样的好处是可以减少网络IO，提升吞吐量。 比如说原本我有三条消息,如果三条消息分三次发的话,会走三次网络IO,如果我给三条消息整成一起发送,这样就走一次网络了。 "),i(a,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667304196521-865cb3ee-ab0d-4c62-90e5-7b6cf5bff2f4.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=846&id=uec728440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=846&originWidth=1402&originalType=binary&ratio=1&rotation=0&showTitle=false&size=220474&status=done&style=none&taskId=u2ccac6c3-73d4-409a-9418-120c3c6ec4c&title=&width=1402",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),O])}const J=d(s,[["render",w]]);export{W as __pageData,J as default};
