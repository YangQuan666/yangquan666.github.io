import{_ as r,b as i,f as c,g as e,h as a,s as t,x as d,e as l}from"./chunks/framework.13bb1723.js";const qe=JSON.parse('{"title":"你真的了解消息队列吗","description":"","frontmatter":{"title":"你真的了解消息队列吗","date":"2022-11-11T00:00:00.000Z","excerpt":"消息队列是一种高效的异步通信机制，能够在分布式系统中实现解耦、削峰填谷和可靠性等优势。我们将深入探讨消息队列的工作原理、应用场景以及常见的消息队列系统，为读者提供全面的了解和应用指导","tags":["mq","消息队列","kafka","time wheel"]},"headers":[],"relativePath":"post/message-queue.md","filePath":"post/message-queue.md","lastUpdated":1684750328000}'),s={name:"post/message-queue.md"},n=e("h1",{id:"你真的了解消息队列吗",tabindex:"-1"},[t("你真的了解消息队列吗 "),e("a",{class:"header-anchor",href:"#你真的了解消息队列吗","aria-label":'Permalink to "你真的了解消息队列吗"'},"​")],-1),h=d("",12),u=d("",27),p=d("",11),m=e("code",null,"Kafka",-1),g=e("code",null,"1ms",-1),_=e("code",null,"TimerTaskList",-1),b=e("code",null,"TimerTask",-1),k=e("code",null,"0",-1),f=e("code",null,"2ms",-1),q=e("code",null,"8ms",-1),T=e("code",null,"2ms",-1),y=e("code",null,"8ms",-1),x=e("code",null,"10ms",-1),P=e("code",null,"10ms",-1),S=e("code",null,"2ms",-1),C=e("code",null,"19ms",-1),A=e("code",null,"2ms",-1),I=e("code",null,"19ms",-1),B=e("code",null,"21ms",-1),D=e("code",null,"21ms",-1),M=e("code",null,"2ms",-1),E=e("code",null,"22ms",-1),Q=e("code",null,"2ms",-1),L=e("code",null,"22ms",-1),z=e("code",null,"24ms",-1),N=e("code",null,"24ms",-1),O=e("code",null,"24ms",-1),V=e("code",null,"24ms",-1),j=e("code",null,"40",-1),K=e("code",null,"[0-399s]",-1),R=e("code",null,"60",-1),w=e("code",null,"[0-7999s]",-1),H=d("",6),v=d("",2),U=e("code",null,"TimerLog",-1),W=e("code",null,"TimerWheel",-1),F=e("h5",{id:"工作流程",tabindex:"-1"},[t("工作流程 "),e("a",{class:"header-anchor",href:"#工作流程","aria-label":'Permalink to "工作流程"'},"​")],-1),G=d("",13),Y={class:"details custom-block"},$=e("summary",null,"答案2",-1),Z=e("code",null,"key",-1),J=e("h3",{id:"消息轨迹",tabindex:"-1"},[t("消息轨迹 "),e("a",{class:"header-anchor",href:"#消息轨迹","aria-label":'Permalink to "消息轨迹"'},"​")],-1),X=e("blockquote",null,[e("p",null,"以蚂蚁的MagBroker为例")],-1),ee=e("p",null,"一条消息的生命周期包含多个阶段：发送端发送，服务端收到消息、写入消息、投递消息等。而用户在使用MQ时，有时会想知道消息的发送、投递、消费情况，以及消费耗时、消费节点、是否重投等信息。这些信息都属于消息轨迹。 在没有可视化的消息轨迹界面时，轨迹信息都是通过原始的翻日志的方式来查询。需要根据机器节点的日志信息找到链路，一步一步溯源查找。",-1),te=d("",5),oe=e("h4",{id:"读取轨迹",tabindex:"-1"},[t("读取轨迹 "),e("a",{class:"header-anchor",href:"#读取轨迹","aria-label":'Permalink to "读取轨迹"'},"​")],-1),ae=e("p",null,[t("当用户登录消息控制台创建查询任务，消息控制台会向轨迹集群内的各个服务发送请求，轨迹数据存储在轨迹集群下各服务的本地"),e("code",null,"AntKV"),t("中。因为消息服务发送轨迹信息消息至轨迹服务时的节点选取是随机的，所以数据会散落在集群内各服务上。因此控制台服务在查询轨迹时需要遍历轨迹集群下的所有轨迹服务，才能获得完整的轨迹信息。")],-1),de=e("h2",{id:"稳定性-性能",tabindex:"-1"},[t("稳定性&性能 "),e("a",{class:"header-anchor",href:"#稳定性-性能","aria-label":'Permalink to "稳定性&性能"'},"​")],-1),re=e("h4",{id:"高可用",tabindex:"-1"},[t("高可用 "),e("a",{class:"header-anchor",href:"#高可用","aria-label":'Permalink to "高可用"'},"​")],-1),ie=e("h5",{id:"消费一致性",tabindex:"-1"},[t("消费一致性 "),e("a",{class:"header-anchor",href:"#消费一致性","aria-label":'Permalink to "消费一致性"'},"​")],-1),ce=d("",4),le=e("h5",{id:"_1-逻辑分区",tabindex:"-1"},[t("1. 逻辑分区 "),e("a",{class:"header-anchor",href:"#_1-逻辑分区","aria-label":'Permalink to "1. 逻辑分区"'},"​")],-1),se=e("h5",{id:"_2-持久化",tabindex:"-1"},[t("2. 持久化 "),e("a",{class:"header-anchor",href:"#_2-持久化","aria-label":'Permalink to "2. 持久化"'},"​")],-1),ne=d("",4),he=d("",5);function ue(pe,me,ge,_e,be,ke){const o=i("q-img");return l(),c("div",null,[n,e("p",null,[a(o,{src:"/post/message-queue/intro.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),h,e("p",null,[a(o,{src:"/post/message-queue/pull&push.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),u,e("p",null,[a(o,{src:"/post/message-queue/shiwu.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),p,e("ol",null,[e("li",null,[e("p",null,[m,t("中一个时间轮(TimingWheel)默认是由20个时间格组成，每格的时间跨度是"),g,t("，时间轮底层采用数组实现，数组中的每个元素可以存放一个定时任务列表（TimerTaskList）。"),_,t("是一个环形的双向链表，链表中的每一项表示的都是定时任务项（TimerTaskEntry），其中封装了真正的定时任务"),b,a(o,{src:"/post/message-queue/shijianlun1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("假设初始的时候一个格子一秒，时间轮的指针定格在"),k,t("。此时添加一个超时时间为"),f,t("的任务, 那么这个任务将会插入到第二个时间格中 "),a(o,{src:"/post/message-queue/shijianlun2.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("时间轮的指针到达第二个时间格时, 会处理该时间格上对应的任务 "),a(o,{src:"/post/message-queue/shijianlun3.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("如果这个时候又插入一个延时时间为"),q,t("的任务进来, 这个任务的过期时间就是在当前时间"),T,t("的基础上加"),y,t(", 也就是"),x,t(", 那么这个任务将会插入到过期时间为"),P,t("的时间格中。 "),a(o,{src:"/post/message-queue/shijianlun4.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("如果在当前时间是"),S,t("的时候, 插入一个延时时间为"),C,t("的任务时, 这个任务的过期时间就是在当前时间"),A,t("的基础上加"),I,t(", 也就是"),B,t("，那么这个任务就会插入到过期时间为"),D,t("的时间格中 "),a(o,{src:"/post/message-queue/shijianlun5.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("如果在当前时间是"),M,t("的时候, 插入一个延时时间为"),E,t("的任务, 这个任务的过期时间就是在"),Q,t("的基础上加"),L,t("，也就是"),z,t("，但是显然没有"),N,t("的格子 "),a(o,{src:"/post/message-queue/shijianlun6.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("第一层的时间轮装不下的时候，任务就会放入第二层的时间轮格子中 "),a(o,{src:"/post/message-queue/shijianlun7.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("当第二层时间轮上的任务到期后，就会执行时间轮的降级，原本超时时间为"),O,t("的任务会被从第二层取出来，放入第一层到期时间为"),V,t("的格子中 "),a(o,{src:"/post/message-queue/shijianlun8.gif",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),e("li",null,[e("p",null,[t("从这里可以看出时间轮的巧妙之处，两层时间轮只用了"),j,t("个数组元素，却可以承载"),K,t("的定时任务。而三层时间轮用"),R,t("个数组元素，就可以承载"),w,t("的定时任务 "),a(o,{src:"/post/message-queue/shijianlun9.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])])]),H,e("ol",null,[v,e("li",null,[e("p",null,[U,t("与"),W,t("的协作如下图所示： "),a(o,{src:"/post/message-queue/r_shijianlun1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])])]),F,e("p",null,[a(o,{src:"/post/message-queue/r_shijianlun1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),G,e("details",Y,[$,e("p",null,[t("答：消费者端创建多个内存队列，具有相同"),Z,t("的数据都路由到同一个内存队列；然后每个线程分别消费一个内存队列即可，这样可以保证多个顺序的同时尽可能提高吞吐量 "),a(o,{src:"/post/message-queue/shunxu.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})])]),J,X,ee,e("p",null,[a(o,{src:"/post/message-queue/guiji.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),te,e("p",null,[a(o,{src:"/post/message-queue/guiji1.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),oe,ae,e("p",null,[a(o,{src:"/post/message-queue/guiji2.png",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),de,re,e("p",null,[t("数据备份和故障转移 "),a(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666871933931-97904c34-ab95-4778-9266-8a724d652213.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=ue475ed04&margin=%5Bobject%20Object%5D&name=image.png&originHeight=483&originWidth=1037&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59699&status=done&style=none&taskId=u85dd854e-7f54-4fe9-8d6c-addca350b18&title=&width=518.5",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),ie,e("p",null,[a(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20441/1666873658825-a41e31e0-f7dd-44e7-910c-f1a497841dd2.png#clientId=uecce1891-4c1f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=153&id=ubf45f24c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=306&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=155906&status=done&style=none&taskId=ud3f002cb-af85-4049-9add-af69a19790c&title=&width=540",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" LogEndOffset：每个partition的log最后一条Message的位置。 HighWatermark：取最小LEO，consumer能够看到的此partition的位置。")]),ce,e("p",null,[a(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667303564561-2f07e1f6-7659-42fd-af1c-e6158b2b660d.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=540&id=u0afcf2aa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=540&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=151090&status=done&style=none&taskId=u69fe3af1-8ba5-496f-b9cd-2e6f00ec9b2&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),le,e("p",null,[t("为了提升整体的吞吐量与提供跨副本组的高可用能力，RocketMQ 服务端一般会为单个 Topic 创建多个逻辑分区，即在多个副本组上各自维护部分分区 ( Partition)，我们把它称为队列 (MessageQueue)。同一个副本组上同一个 Topic 的队列数相同并从 0 开始连续编号，不同副本组上的 MessageQueue 数量可以不同。 "),a(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667211128802-1ebe1226-c430-4b6b-a95b-64ae84602146.png#clientId=u732f2838-f0ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=610&id=u13a63bf6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=217091&status=done&style=none&taskId=u1a163547-d3c6-45a3-bacb-68c9b9605a3&title=&width=750",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" 每个Topic在Broker上会划分成几个逻辑队列，每个逻辑队列保存一部分消息数据。从上面模型可以看出，要解决消费并发，就是要利用Queue,一个Topic可以分出更多的queue,每一个queue可以存放在不同的硬件上来提高并发。")]),se,e("p",null,[t("在RocketMQ中消息刷盘主要可以分为同步刷盘和异步刷盘两种。 "),a(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667301973880-fbab5567-a642-42b6-8ead-7fa8e666e23d.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=540&id=u5e5e4647&margin=%5Bobject%20Object%5D&name=image.png&originHeight=908&originWidth=583&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48292&status=done&style=none&taskId=u1e3a47a0-19e3-4baa-b8f2-559591abd3e&title=&width=347",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" 消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。")]),e("p",null,[a(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667302024113-a2ca21dc-b78c-4e84-a005-2a84c19c0f75.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=592&id=ud39bf6fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=906&originWidth=542&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49898&status=done&style=none&taskId=uc5830126-bfa6-4900-9880-40955d7f100&title=&width=354",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"}),t(" 在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘操作，快速写入。")]),ne,e("p",null,[t("批量消息是指将多条小的消息合并成一个批量消息，一次发送出去。这样的好处是可以减少网络IO，提升吞吐量。 比如说原本我有三条消息,如果三条消息分三次发的话,会走三次网络IO,如果我给三条消息整成一起发送,这样就走一次网络了。 "),a(o,{src:"https://intranetproxy.alipay.com/skylark/lark/0/2022/png/20156646/1667304196521-865cb3ee-ab0d-4c62-90e5-7b6cf5bff2f4.png#clientId=ub92ab98a-bea2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=846&id=uec728440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=846&originWidth=1402&originalType=binary&ratio=1&rotation=0&showTitle=false&size=220474&status=done&style=none&taskId=u2ccac6c3-73d4-409a-9418-120c3c6ec4c&title=&width=1402",alt:"",style:{"max-height":"400px"},loading:"lazy",fit:"contain"})]),he])}const Te=r(s,[["render",ue]]);export{qe as __pageData,Te as default};
